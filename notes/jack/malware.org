* Notes
** [2020-01-27 Mon]
Course help email: [[mailto:mare2020ece@gmail.com][mare2020ece@gmail.com]]
Course website: [[http://rci.rutgers.edu/~sa1087]]
* Homework
** HW1
[[https://docs.google.com/document/d/1aNu32_XUJ-QjYssRXdDGC0mFVrMKvvZ5pdPrUU9PejU/edit][Questions]]

*** Lab 1-1
**** Question 1
Yes, 40/71 antiviruses report the executable as a virus, and 32/69
report the DLL as a virus.
**** Question 2
The Time Date Stamp in =IMAGE_FILE_HEADER= reports compile times of
=2010/12/19 Sun 16:16:19 UTC=, and =2010/12/19 Sun 16:16:38 UTC= for
the executable and DLL respectively.
**** Question 3
No, but dependency walker reports only two DLL imports for the
executable, which likely it loads the other DLL in the folder with it.
Neither appear to be packed.
**** Question 4
The executable appears to import various functions related to reading,
writing, and copying files.

[[./lab1-1-imports.png]]

The DLL appears to import functions related to creating mutexes and
processes, and sending/receiving messages over network sockets.

 [[./lab1-1-dll-imports.png]]
**** Question 5
We could also check for any static strings in both files, which could
tip us off on what specific things each file does.

The executable contains a reference to the file name of the DLL file,
along with ="WARNING_THIS_WILL_DESTROY_YOUR_MACHINE"= , and a
suspicious string ="C:\windows\system32\kerne132.dll"=, which is
extremely similar to the system DLL kernel32.dll.

[[./lab1-1-exe-strings.png]]

The DLL has strings of an IP address, and a few strings that sound
like messages sent to that IP: ="execute"= , ="hello"= , and ="sleep"=.

[[./lab1-1-dll-strings.png]]
**** Question 6
We could use wireshark to capture inbound or outbound network traffic,
checking specifically for the IP address we saw in the strings.
**** Question 7
I would guess that the executable drops the DLL into
=C:\windows\system32\kerne132.dll= and then executes it.

From host based indicators I thought it might open a socket, connect
to an IP, and send some sort of hello.

[[./lab1-1-disas.png]]

After static analysis, it looks like it receives executable files and
will spawn processes with code sent over the network by the server.
*** Lab 1-2
**** Question 1
Yes, 39/63 antiviruses report it as a virus.
**** Question 2
Using PEiD, the executable is reported as "Nothing Found*", but the
executable has no normal =.text= or any other sections, just =UPX0=,
=UPX1=, =UPX2=, which makes me think it is packed with =UPX=.

[[./lab1-2-peid.png]]

After downloading and using the UPX tool on the file, we can see that
it was successfully unpacked and we can see the real sections again.

[[./lab1-2-unpack.png]]
**** Question 3
It appears to import various functions related to opening internet
URLs, mutexes, and creating services. This tells us that this malware
probably downloads a malicious file from the internet and creates a
persistent service that runs it.

[[./lab1-2-imports.png]]
**** Question 4
We could check the system services for the infected service that the
malware creates, or determine the sites that the malware makes network
requests to by further analysis, and monitor traffic to these sites.
*** Lab 1-3
**** Question 1
Yes, 61/71 antiviruses report it as a virus.
**** Question 2
Using PEiD, the executable is reported as being packed with FSG 1.0.

[[./lab1-3-peid.png]]

After using OllyDBG to find the original entry point, I was able to
dump the packed executable and reconstruct the imports table with
OllyDump.

[[./lab1-3-dbg.png]]

[[./lab1-3-unpacked.png]]

Looking at the disassembly, we can see a call to =CoCreateInstance=,
which creates an instance of a COM object.

[[./lab1-3-cocreate.png]]

We can determine which COM object it is instantiating via the =riid=
parameter, which after looking at it in the data segment, appears to
be =D30C1661-CDAF-11D0-A83E-00C04FC9E26E=.

[[./lab1-3-riid.png]]

Searching the registry for this value, we find that the COM object is
=IWebBrowser2=.

[[./lab1-3-reg.png]]

We can then add a structure that contains the vtable for this COM
object to see what methods the malware calls:

[[./lab1-3-struct.png]]

Now we can update the offset to =edx= to be an offset into this
struct, and we can see that the malware calls the =Navigate= function,
which opens a web browser to the passed URL.

[[./lab1-3-resolve.png]]
**** Question 3
It appears to import functions related to manipulating COM objects, so
it likely calls out to some other COM api.
**** Question 4
While the malware doesn't appear to do much, we could use Wireshark or
other network monitoring tools to watch for internet traffic to the
URL we found.
*** Lab 1-4
**** Question 1
Yes, 55/68 antiviruses report it as a virus.
**** Question 2
Using PEiD, the executable doesn't appear to be packed.

[[./lab1-4-peid.png]]
**** Question 3
The Time Date Stamp in =IMAGE_FILE_HEADER= reports a compile time of
=2019/08/30 Fri 22:26:59 UTC=.
**** Question 4
It appears to import various functions related to reading attached
resources, loading libraries, creating thread in remote processes, and
writing files.

These routines seem typical of a malware that injects code into
another process.

[[./lab1-4-imports.png]]
**** Question 5
We could use Wireshark or other network monitoring tools to watch for
internet traffic, checking specifically for the URL present in the
strings of the attached resources.
**** Question 6
Using Resource Hacker, we can see the file contains one resource which
is also an executable (the data starts with the two bytes =MZ=).

[[./lab1-4-resource.png]]

Looking at the imports and strings, this appears to be the part of the
malware that downloads and executes a file from the internet.

[[./lab1-4-resource-imports.png]]

[[./lab1-4-resource-strings.png]]
** HW2
[[https://docs.google.com/document/d/1WhfSneHJmc50FxaL85B-_XoYceXu70la25Y7vEWHawg/edit][Questions]]
*** Lab 3-1
**** Question 1
It contains only 1 import, =ExitProcess=, from =Kernel32.dll=, so it
is clearly packed.

The strings contain various suspicious terms, such as something about
making an HTTP request, autostart registry entries, a website, and
various executable names that appear malicious.

[[./lab3-1-strings1.png]]
[[./lab3-1-strings2.png]]

After running it, we can see the full list of DLLs it imports, which
has lots of stuff about networking, services, and registry editing:

[[./lab3-1-dlls.png]]
**** Question 2
Using Process Monitor, we can see that the malware reads its own image
just before creating a new file called =vmx32to64.exe= and adding a
registry key in =Windows\CurrentVersion\Run\VideoDriver= to start it
on login. =vmx32to64.exe= has the exact same size as the malware
executable, and after hashing each file and getting the same result,
we can confirm it copied itself to run at startup.

[[./lab3-1-drop.png]]
**** Question 3
When we ran Process Monitor before, in addition to the malware
dropping itself, it made some TCP requests. Using Process Monitor,

[[./lab3-1-tcp.png]]

After pinging the IP it connected to, we can confirm that it is
connecting to =www.practicalmalwareanalysis.com=. After redirecting the
DNS to a local netcat server, we can see what appears to be random
data sent over port 443 at each invocation of the malware.
*** Lab 3-2
**** Question 1
The DLL exports a function called ="Install"=, which we can probably
run to get it to install itself.

[[./lab3-2-exports.png]]

Using =rundll32.exe= while we have Process Monitor open with some
filters set up, we can see that the malware creates a service called
=IPRIP=, which calls back out to the DLL file. It doesn't appear to
copy itself anywhere.

[[./lab3-2-svc.png]]
**** Question 2
Since the malware has created a service, we can start it with 
=net start IPRIP=.
**** Question 3
We can use the "Find Handle or DLL" function in Process Explorer to
find which =svchost.exe= process is running our service.

[[./lab3-2-procexp.png]]
**** Question 4
We could use the PID of this specific instance of =svchost.exe=.
**** Question 5
The only host based indicators seem to be the registry keys making up
the service that is installed by the malware, and the malware file
itself.
**** Question 6
Using ApateDNS, we can see the malware seems to do a reverse DNS
lookup for a few IP addresses.

[[./lab3-2-dns.png]]
*** Lab 3-3
**** Question 1
When run, Process Explorer shows the process spawn a child called
=svchost.exe=, then the parent process dies, leaving only the newly
spawned =svchost.exe= process.
**** Question 2
Looking at the strings for the created process in Process Explorer, we
can see that the running process clearly isn't the real =svchost.exe=.

[[./lab3-3-strings.png]]
**** Question 3
The malware doesn't appear to create anything but a
=practicalmalwareanalysis.log= file in the working directory.
**** Question 4
The malware is a keylogger. It writes all keystrokes to the
=practicalmalwareanalysis.log= file. We can see it happening
in process monitor whenever we press a key.

[[./lab3-3-keylog.png]]
*** Lab 3-4
**** Question 1
When it is run, the malware deletes itself.

[[./lab3-4-del.png]]
**** Question 2
The malware really doesn't seem to do anything else but delete itself.
We would need static analysis to learn more about what exactly the
malware is doing.
**** Question 3
We could run it under OllyDBG to trace the program execution up until
the program deletes itself.
** HW3
[[https://docs.google.com/document/d/1jN7-0cRM2dUQr-OyMgTzR5cxgj2t39L0Ju7nUKBU7L4/edit?usp=sharing][Questions]]
*** Lab 5-1
**** Question 1
=0x1000D02E=
**** Question 2
=0x100163CC=
**** Question 3
=5=
**** Question 4
=pics.practicalmalwareanalysis.com=
**** Question 5
=20=
**** Question 6
=1=
**** Question 7
=10095B34=
**** Question 8
A command is appended and then it is executed.
**** Question 9
It is set by the return value of =sub_10003695=
**** Question 10
=sub_100052A2= is called.
**** Question 11
Firstly, a subroutine calls that makes sure the OS platform ID is
Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003,
Windows XP, or Windows 2000, and the major version is 5. Otherwise,
=PSLIST= is not run.

Depending on the parameter to the function, a list of running
processes is either written to =xinstall.dll= or sent over the passed
network socket. If a non empty string is passed to the function, the
specific function is opened and some additional information is logged
or sent over the socket.
**** Question 12
Based on the systemcalls, it probably formats and sends a message over
a socket:

- =GetSystemDefaultLangID=
- =malloc/free=
- =sprintf=
- =send=
- =strlen=
**** Question 13
It calls 4 API functions at a depth of 1, and ~31 with a depth of 2.
**** Question 14
EAX is loaded with the string ="[This is CTI]30"=, then 13 is added,
bringing the string to "30". Then atoi is called which converts the
string into a number, and it is multiplied by 1000. Thus, the program
will sleep for 30 seconds.
**** Question 15
- =af= = =2=
- =type= = =1=
- =protocol= = =6=
**** Question 16
- =af= = =AF_INET=
- =type= = =SOCK_STREAM=
- =protocol= = =IPPROTO_TCP=
**** Question 17
Yes. We find one occurrence at =0x100061DB=. We see a number
=0x564D5868= used with the instruction, which corresponds to ASCII
="VMXh"=.

Following the XREFs back to the =Install*= functions, there appears to
also be another VM detection function at =loc_10006119=.
**** Question 18
We find a strange sequence of bytes that seems to be printable. It
could be an encrypted or ciphered string of some sort.
**** Question 19
The script decrypts the string.
**** Question 20
By pressing the =A= key.
**** Question 21
The script XORs each byte with =0x55=, decrypting the string.
** HW4
[[https://docs.google.com/document/d/1lYViOnBkWpGtFUB4LzteoEvrtec5kBMcOVtUTJ0GxW4/edit][Questions]]
*** Lab 6-1
**** Question 1
Checks to see if there is an internet connection present, and printing
a message accordingly.

[[./lab6-1-mainsub.png]]
**** Question 2
It appears to be some sort of printing function.
**** Question 3
It returns with exit code 1 if there is no internet connection,
else 0.
*** Lab 6-2
**** Question 1
Same as Lab 6-1.

[[./lab6-2-mainsub.png]]
**** Question 2
Same as Lab 6-1.
**** Question 3
It reads the contents of the page
[[http://www.practicalmalwareanalysis.com/cc.htm]] into a buffer.
**** Question 4
Looks like an unrolled loop, looking for a string beginning with =<!--=,
which is the start of an HTML comment.

[[./lab6-2-loop.png]]
**** Question 5
The program checks the internet connection, and if connected makes a
request to [[http://www.practicalmalwareanalysis.com/cc.htm]].
**** Question 6
It checks the internet connection, and if so prints out a byte as a
"command" from an HTML comment on a webpage, then sleeps and exits.
*** Lab 6-3
**** Question 1
There's a new subroutine that does something with the command instead
of just exiting.

[[./lab6-3-sub.png]]
**** Question 2
A filename and a buffer. In this case it's called with the path of the
running program, and the command.
**** Question 3
Looks like a jump table based on the command.

[[./lab6-3-jumps.png]]
**** Question 4
It can do 5 different things depending on the command, either create a
directory =C:\Temp=, copy itself to =C:\Temp\cc.exe=, delete
=C:\Temp\cc.exe=, add =C:\Temp\cc.exe= to the startup registry key, or
sleep and exit.
**** Question 5
It can create the file =C:\Temp\cc.exe= or the registry key
=Software\Microsoft\Windows\CurrentVersion\Run\Malware=.
**** Question 6
The program makes sure there is an internet connection, then reads a
command from a command and control server, then does some various
things based on the command.
*** Lab 6-4
**** Question 1
The command parsing function has a new argument.
**** Question 2
A loop has been added around the main body.

[[./lab6-4-loop.png]]
**** Question 3
It now uses the loop counter in the user agent used to make the
request to the webpage.
**** Question 4
The main loop runs 1440 times, each loop sleeping 60 seconds plus any
network request time, so for around 1 day.
**** Question 5
The user agent is different this time.
**** Question 6
Same as the last one, except it now executes commands repeatedly
instead of just once.
** HW5
[[https://docs.google.com/document/d/1-ne6wM4j62DeNSo47u5rZV3XYM8Ev_LplBILcEMCsNo/edit][Questions]]
*** Lab 7-1
**** Question 1
The malware creates a service called =MalService=.
[[./lab7-1-svc.png]]
**** Question 2
It prevents multiple instances of the malware from running at the same
time.
**** Question 3
The mutex and the service.
**** Question 4
The malware opens a URL in internet explorer with a predefined user agent.
[[./lab7-1-net.png]]
**** Question 5
The malware waits until a certain date, then creates 20 threads that
make requests to =practicalmalwareanalysis.com= in a loop.
**** Question 6
The program waits until the target date, then sends requests forever.
*** Lab 7-2
**** Question 1
As far as I can tell, it doesn't.
**** Question 2
It uses the same method from a previous lab to display the webpage
=malwareanalysisbook.com/ad.html=.
**** Question 3
Right after the page is opened.
*** Lab 7-3
**** Question 1
The malware maps copies of both the malicious DLL and
=System32\Kernel32.dll=, makes a bunch of weird patches, to the mapped
files, then copies it to =System32\kerne132.dll=. It then calls a
function with the parameter =C:\*=. This function walks the directory
calling itself recursively on all subfolders, and calling another
function on any =.exe= files found. This next function maps the file
and does a string search for =Kernel32.dll=, replacing it with the
malicious =kerne132.dll=, which has the effect of overwriting the
import table so the malicious DLL is loaded by every executable
infected.

[[./lab7-3-rewrite.png]]
**** Question 2
The malicious DLL resides in =System32\kerne132.dll=, and creates a
mutex called =SADHUHF=,
**** Question 3
It infects every executable on the system with an import of a
malicious DLL, which once running opens a socket and reads commands
from =127.26.152.13=, which includes starting arbitrary processes.

[[./lab7-3-control.png]]
**** Question 4
You would have to fix the import table of every single affected
executable. Or... a quick temporary fix would be to replace the
malicious =kerne132.dll= with a copy of the original =Kernel32.dll=.
** HW6
*** Phase 1
This phase simply does only simple string compare.
[[./bomb-1.png]]
*** Phase 2
This phase reads in six numbers and checks the values.

We can easily see that the first number has to be one. The following
code checks in a loop that the next number is equal to its index plus
one, multiplied by the last index.

That means that the second number has to be =2 * 1 = 2=, then =3 * 2 =
6=, =4 * 6 = 24=, etc.

This yields the solution =1 2 6 24 120 720=.

 [[./bomb-2.png]]
*** Phase 3
This phase reads in two numbers and a character.

The first number is indexed into a jump table with 8 cases, exploding
if out of range.

Each target of the jump table compares the second number with a
required value, and loads a required value for the char to be compared
with.

[[./bomb-3.png]]


We can just pick the first one, from which we can see the solution is
=0 q 777=.

[[./bomb-3-case.png]]
*** Phase 4
This phase reads in a single number that must be greater than zero,
calls a function, and explodes unless the return value is =55=.

[[./bomb-4.png]]

This function can be summarized as:

#+BEGIN_SRC python
  def func4(n):
      if n <= 1:
          return 1
      else:
          return func4(n - 1) + func4(n - 2)
#+END_SRC

Which clearly computes fibonacci numbers.

Thus, the required input to get =55= is =9=.

[[./bomb-4-func.png]]
*** Phase 5
This phase reads in a string of 6 characters.

It translates the input string into a new buffer, comparing it with
the string ="giants"=.

The function takes the lower 4 bits of each input character, indexing
it into a table to get the resulting character.

We can inspect the table to figure out that the required byte sequence
get ="giants"= is =1111, 0000, 0101, 1011, 1101, 0001=. Cross
referencing this with a binary ascii table, one possible input string
that produces this sequence is ="O@EKMA"=.

[[./bomb-5.png]]
*** Phase 6
This phase again reads in six numbers.

The function first makes sure all numbers are <= 6.

[[./bomb-6-1.png]]

Then it starts a nested loop, comparing each number with every other
number. The bomb explodes if any two are the same.

[[./bomb-6-2.png]]


We see that structures in the data segment are indexed based on the
numbers. Each successive compare must be less than the previous.
Inspecting these values, we clearly see a linked list of values, and
sorting them in decreasing order yields the solution =4 2 6 3 1 5=.

[[./bomb-6-3.png]]
*** Secret Phase
The bomb also contains a secret phase. It is called by the
=phase_defused= method after phase 4 is solved, and scans for the
string ="austinpowers"= in addition to the integer solution.

[[./bomb-secret-1.png]]

The phase reads in another integer, making sure it is less than or
equal to =1001=.

It then calls a new function with another data segment structure, and
explodes unless the result is 7.

[[./bomb-secret-2.png]]


Looking at this structure, it's clearly a binary tree.

[[./bomb-secret-3.png]]

If the passed tree node's value is zero, the function returns -1. If
the node's value is less than the input, it returns twice the result
of recursing with the left child, and the same input. Otherwise, it
returns twice the result plus one of recursing with the right child,
and the same input.

In order to solve this, we must find a path down the tree where the
result is multiplied and added to get 7.

Tracing out the call structure, we find that the input =1001= is
required, defusing the secret phase.

[[./bomb-secret-4.png]]


