* Notes
** [2020-01-27 Mon]
Course help email: [[mailto:mare2020ece@gmail.com][mare2020ece@gmail.com]]
Course website: [[http://rci.rutgers.edu/~sa1087]]
* Homework
** HW1
[[https://docs.google.com/document/d/1aNu32_XUJ-QjYssRXdDGC0mFVrMKvvZ5pdPrUU9PejU/edit][Questions]]

*** Lab 1-1
**** Question 1
Yes, 40/71 antiviruses report the executable as a virus, and 32/69
report the DLL as a virus.
**** Question 2
The Time Date Stamp in =IMAGE_FILE_HEADER= reports compile times of
=2010/12/19 Sun 16:16:19 UTC=, and =2010/12/19 Sun 16:16:38 UTC= for
the executable and DLL respectively.
**** Question 3
No, but dependency walker reports only two DLL imports for the
executable, which likely it loads the other DLL in the folder with it.
Neither appear to be packed.
**** Question 4
The executable appears to import various functions related to reading,
writing, and copying files.

[[./lab1-1-imports.png]]

The DLL appears to import functions related to creating mutexes and
processes, and sending/receiving messages over network sockets.

 [[./lab1-1-dll-imports.png]]
**** Question 5
We could also check for any static strings in both files, which could
tip us off on what specific things each file does.

The executable contains a reference to the file name of the DLL file,
along with ="WARNING_THIS_WILL_DESTROY_YOUR_MACHINE"= , and a
suspicious string ="C:\windows\system32\kerne132.dll"=, which is
extremely similar to the system DLL kernel32.dll.

[[./lab1-1-exe-strings.png]]

The DLL has strings of an IP address, and a few strings that sound
like messages sent to that IP: ="execute"= , ="hello"= , and ="sleep"=.

[[./lab1-1-dll-strings.png]]
**** Question 6
We could use wireshark to capture inbound or outbound network traffic,
checking specifically for the IP address we saw in the strings.
**** Question 7
I would guess that the executable drops the DLL into
=C:\windows\system32\kerne132.dll= and then executes it.

From host based indicators I thought it might open a socket, connect
to an IP, and send some sort of hello.

[[./lab1-1-disas.png]]

After static analysis, it looks like it receives executable files and
will spawn processes with code sent over the network by the server.
*** Lab 1-2
**** Question 1
Yes, 39/63 antiviruses report it as a virus.
**** Question 2
Using PEiD, the executable is reported as "Nothing Found*", but the
executable has no normal =.text= or any other sections, just =UPX0=,
=UPX1=, =UPX2=, which makes me think it is packed with =UPX=.

[[./lab1-2-peid.png]]

After downloading and using the UPX tool on the file, we can see that
it was successfully unpacked and we can see the real sections again.

[[./lab1-2-unpack.png]]
**** Question 3
It appears to import various functions related to opening internet
URLs, mutexes, and creating services. This tells us that this malware
probably downloads a malicious file from the internet and creates a
persistent service that runs it.

[[./lab1-2-imports.png]]
**** Question 4
We could check the system services for the infected service that the
malware creates, or determine the sites that the malware makes network
requests to by further analysis, and monitor traffic to these sites.
*** Lab 1-3
**** Question 1
Yes, 61/71 antiviruses report it as a virus.
**** Question 2
Using PEiD, the executable is reported as being packed with FSG 1.0.

[[./lab1-3-peid.png]]

After using OllyDBG to find the original entry point, I was able to
dump the packed executable and reconstruct the imports table with
OllyDump.

[[./lab1-3-dbg.png]]

[[./lab1-3-unpacked.png]]

Looking at the disassembly, we can see a call to =CoCreateInstance=,
which creates an instance of a COM object.

[[./lab1-3-cocreate.png]]

We can determine which COM object it is instantiating via the =riid=
parameter, which after looking at it in the data segment, appears to
be =D30C1661-CDAF-11D0-A83E-00C04FC9E26E=.

[[./lab1-3-riid.png]]

Searching the registry for this value, we find that the COM object is
=IWebBrowser2=.

[[./lab1-3-reg.png]]

We can then add a structure that contains the vtable for this COM
object to see what methods the malware calls:

[[./lab1-3-struct.png]]

Now we can update the offset to =edx= to be an offset into this
struct, and we can see that the malware calls the =Navigate= function,
which opens a web browser to the passed URL.

[[./lab1-3-resolve.png]]
**** Question 3
It appears to import functions related to manipulating COM objects, so
it likely calls out to some other COM api.
**** Question 4
While the malware doesn't appear to do much, we could use Wireshark or
other network monitoring tools to watch for internet traffic to the
URL we found.
*** Lab 1-4
**** Question 1
Yes, 55/68 antiviruses report it as a virus.
**** Question 2
Using PEiD, the executable doesn't appear to be packed.

[[./lab1-4-peid.png]]
**** Question 3
The Time Date Stamp in =IMAGE_FILE_HEADER= reports a compile time of
=2019/08/30 Fri 22:26:59 UTC=.
**** Question 4
It appears to import various functions related to reading attached
resources, loading libraries, creating thread in remote processes, and
writing files.

These routines seem typical of a malware that injects code into
another process.

[[./lab1-4-imports.png]]
**** Question 5
We could use Wireshark or other network monitoring tools to watch for
internet traffic, checking specifically for the URL present in the
strings of the attached resources.
**** Question 6
Using Resource Hacker, we can see the file contains one resource which
is also an executable (the data starts with the two bytes =MZ=).

[[./lab1-4-resource.png]]

Looking at the imports and strings, this appears to be the part of the
malware that downloads and executes a file from the internet.

[[./lab1-4-resource-imports.png]]

[[./lab1-4-resource-strings.png]]
** HW2
[[https://docs.google.com/document/d/1WhfSneHJmc50FxaL85B-_XoYceXu70la25Y7vEWHawg/edit][Questions]]
*** Lab 3-1
**** Question 1
It contains only 1 import, =ExitProcess=, from =Kernel32.dll=, so it
is clearly packed.

The strings contain various suspicious terms, such as something about
making an HTTP request, autostart registry entries, a website, and
various executable names that appear malicious.

[[./lab3-1-strings1.png]]
[[./lab3-1-strings2.png]]

After running it, we can see the full list of DLLs it imports, which
has lots of stuff about networking, services, and registry editing:

[[./lab3-1-dlls.png]]
**** Question 2
Using Process Monitor, we can see that the malware reads its own image
just before creating a new file called =vmx32to64.exe= and adding a
registry key in =Windows\CurrentVersion\Run\VideoDriver= to start it
on login. =vmx32to64.exe= has the exact same size as the malware
executable, and after hashing each file and getting the same result,
we can confirm it copied itself to run at startup.

[[./lab3-1-drop.png]]
**** Question 3
When we ran Process Monitor before, in addition to the malware
dropping itself, it made some TCP requests. Using Process Monitor,

[[./lab3-1-tcp.png]]

After pinging the IP it connected to, we can confirm that it is
connecting to =www.practicalmalwareanalysis.com=. After redirecting the
DNS to a local netcat server, we can see what appears to be random
data sent over port 443 at each invocation of the malware.
*** Lab 3-2
**** Question 1
The DLL exports a function called ="Install"=, which we can probably
run to get it to install itself.

[[./lab3-2-exports.png]]

Using =rundll32.exe= while we have Process Monitor open with some
filters set up, we can see that the malware creates a service called
=IPRIP=, which calls back out to the DLL file. It doesn't appear to
copy itself anywhere.

[[./lab3-2-svc.png]]
**** Question 2
Since the malware has created a service, we can start it with 
=net start IPRIP=.
**** Question 3
We can use the "Find Handle or DLL" function in Process Explorer to
find which =svchost.exe= process is running our service.

[[./lab3-2-procexp.png]]
**** Question 4
We could use the PID of this specific instance of =svchost.exe=.
**** Question 5
The only host based indicators seem to be the registry keys making up
the service that is installed by the malware, and the malware file
itself.
**** Question 6
Using ApateDNS, we can see the malware seems to do a reverse DNS
lookup for a few IP addresses.

[[./lab3-2-dns.png]]
*** Lab 3-3
**** Question 1
When run, Process Explorer shows the process spawn a child called
=svchost.exe=, then the parent process dies, leaving only the newly
spawned =svchost.exe= process.
**** Question 2
Looking at the strings for the created process in Process Explorer, we
can see that the running process clearly isn't the real =svchost.exe=.

[[./lab3-3-strings.png]]
**** Question 3
The malware doesn't appear to create anything but a
=practicalmalwareanalysis.log= file in the working directory.
**** Question 4
The malware is a keylogger. It writes all keystrokes to the
=practicalmalwareanalysis.log= file. We can see it happening
in process monitor whenever we press a key.

[[./lab3-3-keylog.png]]
*** Lab 3-4
**** Question 1
When it is run, the malware deletes itself.

[[./lab3-4-del.png]]
**** Question 2
The malware really doesn't seem to do anything else but delete itself.
We would need static analysis to learn more about what exactly the
malware is doing.
**** Question 3
We could run it under OllyDBG to trace the program execution up until
the program deletes itself.
** HW3
[[https://docs.google.com/document/d/1jN7-0cRM2dUQr-OyMgTzR5cxgj2t39L0Ju7nUKBU7L4/edit?usp=sharing][Questions]]
*** Lab 5-1
**** Question 1
=0x1000D02E=
**** Question 2
=0x100163CC=
**** Question 3
=5=
**** Question 4
=pics.practicalmalwareanalysis.com=
**** Question 5
=20=
**** Question 6
=1=
**** Question 7
=10095B34=
**** Question 8
A command is appended and then it is executed.
**** Question 9
It is set by the return value of =sub_10003695=
**** Question 10
=sub_100052A2= is called.
**** Question 11
Firstly, a subroutine calls that makes sure the OS platform ID is
Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003,
Windows XP, or Windows 2000, and the major version is 5. Otherwise,
=PSLIST= is not run.

Depending on the parameter to the function, a list of running
processes is either written to =xinstall.dll= or sent over the passed
network socket. If a non empty string is passed to the function, the
specific function is opened and some additional information is logged
or sent over the socket.
**** Question 12
Based on the systemcalls, it probably formats and sends a message over
a socket:

- =GetSystemDefaultLangID=
- =malloc/free=
- =sprintf=
- =send=
- =strlen=
**** Question 13
It calls 4 API functions at a depth of 1, and ~31 with a depth of 2.
**** Question 14
EAX is loaded with the string ="[This is CTI]30"=, then 13 is added,
bringing the string to "30". Then atoi is called which converts the
string into a number, and it is multiplied by 1000. Thus, the program
will sleep for 30 seconds.
**** Question 15
- =af= = =2=
- =type= = =1=
- =protocol= = =6=
**** Question 16
- =af= = =AF_INET=
- =type= = =SOCK_STREAM=
- =protocol= = =IPPROTO_TCP=
**** Question 17
Yes. We find one occurrence at =0x100061DB=. We see a number
=0x564D5868= used with the instruction, which corresponds to ASCII
="VMXh"=.

Following the XREFs back to the =Install*= functions, there appears to
also be another VM detection function at =loc_10006119=.
**** Question 18
We find a strange sequence of bytes that seems to be printable. It
could be an encrypted or ciphered string of some sort.
**** Question 19
The script decrypts the string.
**** Question 20
By pressing the =A= key.
**** Question 21
The script XORs each byte with =0x55=, decrypting the string.
** HW4
[[https://docs.google.com/document/d/1lYViOnBkWpGtFUB4LzteoEvrtec5kBMcOVtUTJ0GxW4/edit][Questions]]
*** Lab 6-1
**** Question 1
Checks to see if there is an internet connection present, and printing
a message accordingly.

[[./lab6-1-mainsub.png]]
**** Question 2
It appears to be some sort of printing function.
**** Question 3
It returns with exit code 1 if there is no internet connection,
else 0.
*** Lab 6-2
**** Question 1
Same as Lab 6-1.

[[./lab6-2-mainsub.png]]
**** Question 2
Same as Lab 6-1.
**** Question 3
It reads the contents of the page
[[http://www.practicalmalwareanalysis.com/cc.htm]] into a buffer.
**** Question 4
Looks like an unrolled loop, looking for a string beginning with =<!--=,
which is the start of an HTML comment.

[[./lab6-2-loop.png]]
**** Question 5
The program checks the internet connection, and if connected makes a
request to [[http://www.practicalmalwareanalysis.com/cc.htm]].
**** Question 6
It checks the internet connection, and if so prints out a byte as a
"command" from an HTML comment on a webpage, then sleeps and exits.
*** Lab 6-3
**** Question 1
There's a new subroutine that does something with the command instead
of just exiting.

[[./lab6-3-sub.png]]
**** Question 2
A filename and a buffer. In this case it's called with the path of the
running program, and the command.
**** Question 3
Looks like a jump table based on the command.

[[./lab6-3-jumps.png]]
**** Question 4
It can do 5 different things depending on the command, either create a
directory =C:\Temp=, copy itself to =C:\Temp\cc.exe=, delete
=C:\Temp\cc.exe=, add =C:\Temp\cc.exe= to the startup registry key, or
sleep and exit.
**** Question 5
It can create the file =C:\Temp\cc.exe= or the registry key
=Software\Microsoft\Windows\CurrentVersion\Run\Malware=.
**** Question 6
The program makes sure there is an internet connection, then reads a
command from a command and control server, then does some various
things based on the command.
*** Lab 6-4
**** Question 1
The command parsing function has a new argument.
**** Question 2
A loop has been added around the main body.

[[./lab6-4-loop.png]]
**** Question 3
It now uses the loop counter in the user agent used to make the
request to the webpage.
**** Question 4
The main loop runs 1440 times, each loop sleeping 60 seconds plus any
network request time, so for around 1 day.
**** Question 5
The user agent is different this time.
**** Question 6
Same as the last one, except it now executes commands repeatedly
instead of just once.
